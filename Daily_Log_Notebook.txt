7/14 Update:

Today I worked on 2 things:

    1. Coding an algorithm utilizing heuristics that I thought I could solve the problem
    2. Researchng more about heuristics and graph theory in general

For the coding side of things. I had a couple of ideas for the code I had done yesterday. 
I wrote a cleaner and commented version of that idea. However, it turns out that the code is as accurate as I had hoped. 
From my debugging and testing, I have deduced that the problem is my algorithm takes the vertex with a lower id when two vertices have the same "potential" destination points. 
If I were to try and fix this, it would very likely become a recursive function with what I have in mind. I'll have to more testing on that.

For research, I search online about the longest path of an undirected, unweighted graph and found very little as it is an NP-hard problem. 
However, there were people talking about longest path on unweighted trees, which I remember Bart talking about in the first meeting we had. 
I also saw people were discussing both DFS and BFS so i wonder if those can somehow be used on undirected, unweighted graphs in general.


7/15 Update:
Today I worked on 3 things:

    1. Cleaning code and git repo as per Bart and Cassaundra's suggestions
    2. Wrote and ran a benchmarking program for testing runtimes of my brute-force longest path algorithm and my antigreedy heuristic
    3. Read the paper explaining Dijkstra's formula and attempted to implement it into Python

For cleaning my code and repo, I basically went through a checklist of my notes from the 7/14 weekly meeting:
    - Added basic overview and name to the top of all files
    - Changed all file names to lowercase
    - Change file names to better describe their function
    - Streamlined areas of code that were in need of some revisions

For benchmarking, I did as Bart suggested and ran 4 functions, two for the brute-force algorithm, and two for my heuristic. 
I tested both as functions of n (nodes) and m (edges) and found that many of the functions had exponential trendlines.
I ran the 4 functions in 2 seperate runs to get more results, but overall found that the graphs in run 1 matched those in run 2
Also I found that my heuristic was far more efficient than the brute-force algorithm, allowing me to run much larger node and edge ranges.
Note: When testing the runtimes as a function of nodes, Run1 and Run2 were both done with the 3/4 the maximum amount of possible edges.
The graphs that I got from benchmarking are in the folder labeled 'longest_path_benchmarking_data'

For Dijstrka's algorithm, I read the paper. Much of it was quite confusing, but I felt like I understood enough to implement it.
I understood that there were 2 breadth first searches performed to find two "extremes" in a tree in order to find the longest path.
I programmed that in python and uploaded it to my repo under the name 'implementing_dijkstras'


7/18 Update:
Today I worked mainly worked on some ideas that I had.

Using Dijkstra's algorithm that I programmed last Friday, I tried to use it on graphs other than trees and went on a deep dive 
to see if I could convert non-tree graphs into tree-graphs using Prim's or Kruksal's spanning tree algorithms.

I also looked into depth first search to see how it might help me in my heuristics.

Currently, for both of these items, I still have some ideas I want to test tomorrow, but today they did not yield too much.


7/19 Update:
Today I worked on 2 things:

    1. Finish testing my ideas for topological sort, DFS, and spanning tree related code
    2. Worked on the new algorithm that Bart gave me

For testing my own ideas, I thought that I was onto something with DFS and spanning trees by cutting unwanted edges into a tree so I could use Dijkstra's tree algorithm.
This did not yield any success, however, it does seem like I was on the right track.

For the new algorithm that Bart gave me, I worked on internalizing what it was doing and drawing a few proof-of-concept graphs to experiment with it.
It turns out that the direction I was going with DFS and spanning trees was the right direction with the wrong approach.
I began to do some concept testing with code in a new file titled "graph_pruning.py" in my github project repo, and will contineu to work on it tomorrow


7/20 Update
Today I worked on:

    1. The Periphery Pruning Heuristic

Today, I was able to create a program that find the total periphery at each vertex and colors it a color on a gradient, relative to the other vertex's total periphery. 

I also was able to create a heuristic that removes edges that connect the vertices with the lowest periphery values. 
The heuristic was somewhat accurate when the raph was small (around 7 or 8 vertices), but got more inaccurate as the number of vertices increased.
As it turns out, after writing my pseudocode and discussing with Bart, I realized that I had implemented a different version than we had initially discussed.

Tomorrow, I hope to implement another version of the heuristic that removes edges that connect the vertices with the highest periphery values.
I also hope to implement the heuristic that maximizes the overall periphery of a graph. I'll see how that goes tomorrow.